//@version=6
indicator('Highlight Time', overlay = true, max_lines_count = 500)

// Intrument are Symbols, eg: DJI, NAS, UK100, etc
instrument = syminfo.ticker

// Logging:
// Only on last bar & is newly generated bar
// So that the log is not clogged
// Ok nvm, when i switch to higher timeframe, it has no log, or waiting for one i dk
//      if barstate.islast and barstate.isnew       //
// This one will TRUE every tick.
if barstate.islast
    log.info(instrument + " " + timeframe.period)

my_timezone = "Asia/Kuala_Lumpur"
var current_symbol_timezone = "Asia/Kuala_Lumpur"

// Create input options
size_option = input.string( title = "Font Size", options = ["Tiny", "Small (default)", "Normal", "Large", "Huge", "Auto"], defval = "Small (default)" )
var font_size = size.small

if size_option == "Tiny"
    font_size := size.tiny
else if size_option == "Normal"
    font_size := size.normal
else if size_option == "Large"
    font_size := size.large
else if size_option == "Huge"
    font_size := size.huge
else if size_option == "Auto"
    font_size := size.auto







//
// Draw Trading Time
//
var bool is_daylight_saving = false
var dst_start = ""
var dst_end   = ""
var session_start = timestamp(my_timezone, year(time, my_timezone), month(time, my_timezone), dayofmonth(time, my_timezone), 8, 0, 0)
var session_end   = timestamp(my_timezone, year(time, my_timezone), month(time, my_timezone), dayofmonth(time, my_timezone), 24, 0, 0)

// Default: from 8am to 12am, monday to sunday
var          session_time = "0800-2400"
const string session_days = ":1234567"
var my_session = session_time + session_days

if instrument == "JP225YJPY"
    session_time := "0800-1430"
    current_symbol_timezone := "GMT+9"
    session_start := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 9, 0, 0)
    session_end   := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 15, 30, 0)

if instrument == "HK50"
    session_time := "0900-1600"
    current_symbol_timezone := "GMT+8"
    session_start := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 9, 0, 0)
    session_end   := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 16, 0, 0)

if instrument == "CHINA50"
    session_time := "0900-1500"
    current_symbol_timezone := "GMT+8"
    session_start := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 9, 0, 0)
    session_end   := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 15, 0, 0)

// From what i understand
// timestamp("1 Jan 2025") is the UNIX time since 1 Jan 1970 in UTC +0
// Hence, you should convert UNIX time into UTC+0 first
// Then, you convvert again to Malaysia time GMT+8
// Hence, 1 Jan 2025, will be converted to 8am 1 Jan 2025 to your timezone
// Hence, all these timestamp() will be TRUE after 6am in your timezone
if instrument == "AUS200"
    dst_start := "06 Oct 2024"
    dst_end   := "06 Apr 2025"
    current_symbol_timezone := syminfo.timezone
    session_start := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 10, 0, 0)
    session_end   := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 16, 0, 0)
    if  time > timestamp("6 Oct 2024") and time < timestamp("6 Apr 2025")
        session_time := "0700-1300"
        is_daylight_saving := true
    else
        session_time := "0800-1400"
        is_daylight_saving := false


if instrument == "UK100" or instrument == "GER40"
    dst_start := "30 Mar 2025"
    dst_end   := "26 Oct 2025"
    current_symbol_timezone := "GMT+0"
    session_start := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 8, 0, 0)
    session_end   := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 16, 30, 0)
    // Use "time" dont use "timenow"
    // "time" get the current bar index time
    // "timenow" get the current time regardless bar index
    if  time > timestamp("30 Mar 2025") and time < timestamp("26 Oct 2025")
        session_time := "1500-2330"
        is_daylight_saving := true
    else
        session_time := "1600-0030"
        is_daylight_saving := false

if instrument == "NAS100" or instrument == "US30" or instrument == "SP500"
    dst_start := "09 Mar 2025"
    dst_end   := "02 Nov 2025"
    current_symbol_timezone := syminfo.timezone
    session_start := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 9, 30, 0)
    session_end   := timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), 16, 0, 0)
    if  time > timestamp("09 Mar 2025") and time < timestamp("02 Nov 2025")
        session_time := "2130-0400"
        is_daylight_saving := true
    else
        session_time := "2230-0500"
        is_daylight_saving := false

my_session := session_time + session_days

// Check if the current time is within the specified range, in my timezone
inTimeRange = math.sign(nz(time(timeframe.period, my_session, my_timezone)))

// Plot the background color if the current time is within the range
bgcolor(inTimeRange > 0 ? color.new(color.blue, 90) : na, title = "My session")

if barstate.islast
    current_time = timestamp(current_symbol_timezone, year(time, current_symbol_timezone), month(time, current_symbol_timezone), dayofmonth(time, current_symbol_timezone), hour(time, current_symbol_timezone), minute(time, current_symbol_timezone), second(time, current_symbol_timezone))

    is_in_session = (current_time >= session_start and current_time < session_end)
    var countdown = current_time
    if is_in_session
        // if in session, calculate countdown to session close
        countdown := math.abs(session_end - current_time)
    else
        // else, calculate countdown to session start
        // check if pass session_end, if it is, then need to calculate based on session_start that is tomorrow's
        if current_time > session_end
            session_start := session_start + 86400000
        countdown := math.abs(current_time - session_start)

    // Convert to HH:mm format
    hours_left = math.floor(countdown / 1000 / 60 / 60)
    minutes_left = ((countdown / 1000 / 60 / 60) - hours_left) * 60
    formatted_time = str.tostring(hours_left, "00") + ":" + str.tostring(minutes_left, "00")

    // Draw daylight saving time table
    var dst_table = table.new(position = position.top_right, columns = 1, rows = 3, bgcolor = color.new(color.blue, 90), border_color=color.new(color.blue,50), border_width = 1)
    table.cell(table_id = dst_table, column = 0, row = 0, text_color=color.new(color.white, 30), bgcolor = is_daylight_saving ? color.new(color.purple, 80) : color.new(color.blue, 100), text_size = font_size, text = is_daylight_saving ? "Daylight Saving" : "Standard")
    table.cell(table_id = dst_table, column = 0, row = 1, text_color=color.new(color.white, 30), bgcolor = is_in_session      ? color.new(color.purple, 80) : color.new(color.blue, 100), text_size = font_size, text = session_time + " (" + str.tostring(formatted_time) +")")
    table.cell(table_id = dst_table, column = 0, row = 2, text_color=color.new(color.white, 30), bgcolor = is_daylight_saving ? color.new(color.purple, 80) : color.new(color.blue, 100), text_size = font_size, text = dst_start + " - " + dst_end)

















//
// Draw session break
// It will not draw on H4 and above time
//
var me_sessionBreak = 0
var draw_session_break = true
sessionBreak = time_tradingday

var four_hour = "240"
var daily = "1D"
var monthly = "1M"
var weekly = "1W"

if timeframe.period == four_hour
    draw_session_break := false
if timeframe.period == daily
    draw_session_break := false
if timeframe.period == monthly 
    draw_session_break := false
if timeframe.period == weekly
    draw_session_break := false

if draw_session_break
    if(sessionBreak!=me_sessionBreak)
        me_sessionBreak:=sessionBreak
        // label.new(x=bar_index, y=high, text="New Day")
        // no need bah i guess..
        // line.new(bar_index, low, bar_index, high, style = line.style_dashed)















//
// Draw ATH
// I realize that, if M5, the maximum candle is 5k
// Those ATH that is way before 5k candle, is missed
// Hence, the best way to draw ATH, is draw based on 12 Months timeframe
//

// Draw ATH on Yearly timeframe
// Request Highest for Yearly chart
var ATH = request.security(syminfo.tickerid, "12M", high)
ATH := math.max(high, ATH)

// But then i realize, if you on weekly chart, the value will be "NA"
// Not sure what happened but i guess, can put check if "NA", then draw 
// ATH based on current timeframe
if na(ATH)
    log.info("ATH is NA")
    ATH := high
    ATH := math.max(high, ATH)

// Plot the ATH on the M5 chart
plot_ATH = plot(ATH, color = color.new(color.yellow, 50), title = "ATH Plot", display = display.pane)
plot_price_low = plot(low, display = display.none, title = "Price Low Plot")
fill(plot_price_low, plot_ATH, color = color.new(color.yellow, 95), title = "ATH Fill")

